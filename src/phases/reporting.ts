// =============================================================================
// Inkrypt - Reporting Phase
// Assembles final pentest report with model metadata injection
// =============================================================================

import { readFileSync, writeFileSync, existsSync, readdirSync } from 'fs';
import { join } from 'path';
import type { AgentMetrics } from '../temporal/shared.js';

/**
 * Assemble the final penetration test report.
 * Combines all agent outputs, vulnerability queues, and exploit results.
 */
export async function assembleReport(
  sessionId: string,
  target: string,
  outputDir: string,
  metrics: AgentMetrics[],
): Promise<string> {
  const reportPath = join(outputDir, 'reports', 'pentest-report.md');

  const sections: string[] = [];

  // Header
  sections.push(`# Inkrypt System Penetration Test Report`);
  sections.push('');
  sections.push(`**Target:** ${target}`);
  sections.push(`**Session:** ${sessionId}`);
  sections.push(`**Date:** ${new Date().toISOString().split('T')[0]}`);
  sections.push(`**Generated by:** Inkrypt Autonomous Pentest Framework`);
  sections.push('');
  sections.push('---');
  sections.push('');

  // Executive Summary (from report agent)
  const executiveSummary = readFileSafe(join(outputDir, 'reports', 'executive-summary.md'));
  if (executiveSummary) {
    sections.push('## Executive Summary');
    sections.push('');
    sections.push(executiveSummary);
    sections.push('');
  }

  // Vulnerability Findings
  sections.push('## Vulnerability Findings');
  sections.push('');

  const vulnDomains = ['ssh', 'privesc', 'network', 'misconfig', 'credential'];
  for (const domain of vulnDomains) {
    const vulnFile = join(outputDir, 'vuln-queues', `vuln-queue-${domain}.md`);
    const exploitFile = join(outputDir, 'exploit-results', `exploit-results-${domain}.md`);

    const vulnContent = readFileSafe(vulnFile);
    const exploitContent = readFileSafe(exploitFile);

    if (vulnContent || exploitContent) {
      sections.push(`### ${formatDomainTitle(domain)}`);
      sections.push('');
      if (vulnContent) {
        sections.push('#### Vulnerabilities Identified');
        sections.push(vulnContent);
        sections.push('');
      }
      if (exploitContent) {
        sections.push('#### Exploitation Results');
        sections.push(exploitContent);
        sections.push('');
      }
    }
  }

  // Tool Scan Results
  sections.push('## Tool Scan Results');
  sections.push('');

  const toolOutputDir = join(outputDir, 'tool-outputs');
  if (existsSync(toolOutputDir)) {
    const toolFiles = readdirSync(toolOutputDir).filter((f) => f.endsWith('.txt'));
    for (const file of toolFiles) {
      const content = readFileSafe(join(toolOutputDir, file));
      if (content && content.trim()) {
        sections.push(`### ${file.replace('.txt', '').replace(/-/g, ' ').toUpperCase()}`);
        sections.push('');
        sections.push('```');
        sections.push(content.slice(0, 5000)); // Truncate very long outputs
        sections.push('```');
        sections.push('');
      }
    }
  }

  // Metrics
  sections.push('## Test Metrics');
  sections.push('');
  sections.push('| Agent | Duration | Cost | Tokens | Status |');
  sections.push('|-------|----------|------|--------|--------|');

  for (const m of metrics) {
    const duration = `${Math.round(m.duration / 1000)}s`;
    const cost = `$${m.cost.toFixed(2)}`;
    const tokens = `${m.inputTokens + m.outputTokens}`;
    const status = m.success ? 'Pass' : 'Fail';
    sections.push(`| ${m.agent} | ${duration} | ${cost} | ${tokens} | ${status} |`);
  }

  sections.push('');
  sections.push(`**Total Cost:** $${metrics.reduce((s, m) => s + m.cost, 0).toFixed(2)}`);
  sections.push(`**Total Duration:** ${Math.round(metrics.reduce((s, m) => s + m.duration, 0) / 60000)}m`);
  sections.push('');

  // Model Metadata
  sections.push('## Model Metadata');
  sections.push('');
  sections.push('```json');
  sections.push(JSON.stringify({
    framework: 'Inkrypt',
    version: '1.0.0',
    model: process.env['CLAUDE_MODEL'] ?? 'claude-sonnet-4-5-20250929',
    timestamp: new Date().toISOString(),
    agents: metrics.map((m) => ({
      name: m.agent,
      success: m.success,
      turns: m.turns,
      cost: m.cost,
    })),
  }, null, 2));
  sections.push('```');
  sections.push('');

  // Disclaimer
  sections.push('---');
  sections.push('');
  sections.push('*This report was generated autonomously by the Inkrypt penetration testing framework.*');
  sections.push('*All findings should be validated by a qualified security professional before remediation.*');

  const report = sections.join('\n');
  writeFileSync(reportPath, report, 'utf-8');

  return reportPath;
}

function readFileSafe(filePath: string): string | null {
  try {
    return readFileSync(filePath, 'utf-8');
  } catch {
    return null;
  }
}

function formatDomainTitle(domain: string): string {
  const titles: Record<string, string> = {
    'ssh': 'SSH Security',
    'privesc': 'Privilege Escalation',
    'network': 'Network Services',
    'misconfig': 'System Misconfigurations',
    'credential': 'Credential Security',
  };
  return titles[domain] ?? domain;
}
